# Repository Map Specification

This specification defines requirements for auto-generated contextual summaries of the user's second brain. The repository map provides Claude with intrinsic knowledge of file structure and content without requiring manual exploration or search operations.

---

## Purpose and Scope

Claude operates most effectively when it understands what information exists in the user's knowledge base. Without context, Claude must ask users "what files do you have?" or speculatively search for relevant content. The repository map solves this by providing a structured overview of all files with AI-generated summaries as part of Claude's base knowledge.

**Primary use cases:**

The map MUST enable Claude to answer questions like "do I have notes about X?" without searching. It MUST help Claude suggest relevant files during conversations without the user explicitly requesting them. It MUST provide enough context for Claude to know when deeper exploration (using read or grep tools) would be valuable.

**Distinction from search:**

The repo map provides breadth—a broad overview of everything that exists. Search tools provide depth—detailed content from specific files. The map helps Claude decide whether and where to search; it does not replace search functionality.

**Invisible scaffolding:**

The repo map is NOT exposed as a file or resource that Claude can read. It exists purely as injected context in the system prompt. Users never see the map (unless they inspect prompts), and Claude is never told the map exists. From Claude's perspective, it simply "knows" what files exist and what they contain.

---

## Map Format and Structure

The map MUST use an ASCII tree diagram format displaying the directory hierarchy with file summaries. This format provides maximum information density while remaining readable within token limits.

### Tree Structure Requirements

The tree MUST display directories and files in a hierarchical structure using ASCII box-drawing characters for visual clarity. Directory entries MUST show file counts (e.g., "projects/ (23 files)"). File entries MUST show the filename followed by a dash and single-sentence summary.

The tree MUST be sorted alphabetically within each directory level to ensure consistent output and easier scanning. Hidden files (starting with ".") SHOULD be excluded from the map to reduce noise. System files like ".DS_Store" or ".gitkeep" MUST be excluded.

### Example Format

```
projects/
├── launch-app/ (23 files)
│   ├── architecture.md - System design using React Native and Cloudflare Workers backend
│   ├── marketing-plan.md - Go-to-market strategy targeting mobile-first users in Q1 2025
│   └── requirements.md - Product requirements document with user stories and acceptance criteria
├── learn-spanish/ (12 files)
│   ├── grammar-notes.md - Present tense conjugation patterns and common irregular verbs
│   └── vocabulary.md - Travel-related phrases and expressions for June vacation

areas/
├── health/ (8 files)
│   └── workout-routine.md - Current strength training schedule with progressive overload plan

resources/
├── productivity/ (15 files)
│   └── gtd-summary.md - Getting Things Done methodology overview and weekly review checklist

archives/
└── 2024/ (45 files)
    └── old-project/ - Archived materials from completed initiatives
```

### Token Budget Considerations

The map MUST remain within reasonable token limits even as the second brain grows. For an initial implementation with fewer than 500 files, showing the complete tree with all summaries is acceptable. The system SHOULD monitor map token count and implement truncation strategies when needed.

Future truncation strategies MAY include showing directory-level summaries instead of individual files for large folders, limiting tree depth to two or three levels, or showing only recently modified files. [DEFERRED: Specific truncation thresholds and strategies will be determined based on real-world usage patterns.]

---

## AI Summary Generation

Each file in the map MUST have a single-sentence summary generated by an AI model. Summaries provide Claude with content context without requiring file reads during every conversation.

### Summary Requirements

Summaries MUST be concise—one sentence, maximum 200 characters. They SHOULD capture the file's primary topic or purpose, not just restate the filename. A summary like "Notes about productivity" for "productivity-notes.md" adds no value; "Time-blocking technique for deep work with 90-minute focus sessions" provides useful context.

Summaries MUST be generated from file content, not just metadata. The AI model receives the file's text content (truncated if necessary) and produces a descriptive sentence.

Summaries SHOULD be deterministic when file content hasn't changed. Using the same model and prompt for unchanged content SHOULD produce identical or very similar summaries to avoid unnecessary cache invalidation.

### Model Selection

The system MUST use Cloudflare Workers AI for summary generation to minimize cost and latency. Specifically, the `@cf/meta/llama-3-8b-instruct` model provides a good balance of quality, speed, and cost for single-sentence summarization tasks.

Alternative models like `@cf/mistral/mistral-7b-instruct-v0.1` MAY be used if they demonstrate better performance for this use case. The system MUST store which model generated each summary in the database to support model migrations.

### Prompt Design

The AI prompt MUST request a single-sentence summary with character limit guidance. The prompt SHOULD provide the first 2000 characters of file content as context, which is sufficient for most markdown notes to include title, headings, and opening paragraphs.

Example prompt structure:
```
Summarize this note in ONE sentence (max 100 characters):

[file content truncated to 2000 chars]

Summary:
```

The prompt MAY be refined based on observed summary quality. Prompt engineering improvements do not require specification changes.

---

## Summary Caching and Regeneration

Generating summaries for every file on every request would be prohibitively expensive and slow. The system MUST cache summaries in the D1 database and regenerate them only when necessary.

### Cache Storage

The D1 `file_metadata` table (see [D1 Database](./d1-database.md)) stores AI summaries alongside file metadata. The `ai_summary`, `summary_generated_at`, and `summary_model` fields track cached summaries and their freshness.

### Change Detection

The system MUST detect when file content changes to trigger summary regeneration. This detection uses SHA-256 content hashing stored in the `content_hash` field. When a file is written or edited, the system computes the new content hash. If the hash differs from the stored hash, the file has changed and needs a new summary.

### Regeneration Strategy

Summary regeneration MUST occur in two scenarios: (1) when a file is first created, generate a summary immediately during the write operation, (2) when file content changes, mark the summary as stale but regenerate during the next daily cron job.

The immediate generation on file creation ensures new files appear in the repo map with summaries on the next request. Delayed regeneration for edits avoids blocking user operations while ensuring summaries eventually update.

### Daily Cron Job

The existing daily cron job (see [Deployment](./deployment.md) for cron configuration) MUST include a summary regeneration phase. This job queries the database for files where `content_hash` has changed since `summary_generated_at` or where `ai_summary` is null.

The job MUST process files in batches to respect Cloudflare Workers CPU time limits. A batch size of 50 files per day provides a reasonable default. If more than 50 files need regeneration, the job processes the 50 most recently modified files and handles the remainder the next day.

The job SHOULD prioritize recently modified files over older files to ensure active content has fresh summaries. Files that rarely change can tolerate stale summaries longer than frequently edited documents.

---

## Map Assembly and Injection

The repository map is assembled on-demand during MCP server initialization for each request. This ensures Claude always sees the current file structure even though summaries may be slightly stale (up to 24 hours old for edited files).

### Assembly Process

The map assembly MUST read all file metadata from the D1 database in a single query ordered by path. This query provides file paths, summaries, and modification timestamps needed to build the tree.

The assembly process MUST construct the ASCII tree structure from the flat list of file paths. This involves parsing paths into directory hierarchies, counting files per directory, and formatting the output with appropriate indentation and tree characters.

Files with null summaries (not yet generated) MUST still appear in the tree. The summary position shows "[generating...]" or similar placeholder to indicate work in progress. This is preferable to omitting files from the map entirely.

### Performance Requirements

Map assembly MUST complete in under 100ms for knowledge bases with fewer than 1000 files. This target ensures the map can be generated on every request without significantly impacting latency.

The assembly process SHOULD cache the generated map text for a short duration (10-30 seconds) to avoid redundant assembly when multiple requests arrive in quick succession. Cache invalidation on file writes is not required—slightly stale maps (showing files created seconds ago) are acceptable.

### System Prompt Injection

The assembled map MUST be injected into the system prompt after AGENTS.md content and before any request-specific context. The injection point follows this order:

1. Hardcoded core system prompt (security constraints, server identity)
2. AGENTS.md content (user methodology and preferences)
3. Repository map (current file structure and summaries)
4. Request-specific context (if any)

This ordering ensures Claude understands its purpose and methodology before receiving concrete knowledge about what files exist. Claude can then apply methodology principles to specific files it knows about.

The map MUST be prefixed with a clear heading like "# Current Brain Map" to separate it from AGENTS.md content. No additional explanation or instructions about the map are needed—Claude implicitly understands that this information represents available knowledge.

---

## Migration and Bootstrap

The repository map feature requires D1 database support. The migration path MUST handle existing deployments that have files in R2 but no metadata in D1.

### Initial Deployment

When first deploying the repo map feature, the system MUST run a backfill job to populate file metadata for all existing R2 objects. This backfill (specified in [D1 Database](./d1-database.md)) creates metadata records with null summary fields.

After backfill completes, the daily cron job begins generating summaries at a rate of 50 files per day. Users with hundreds of files will see the map gradually populate with summaries over several days. This gradual approach avoids overwhelming Workers AI with thousands of concurrent summarization requests.

### Bootstrap Behavior

The bootstrap process (see [Bootstrap](./bootstrap.md)) creates initial AGENTS.md content. Since the repo map shows current file state, no special bootstrap requirements exist beyond ensuring the metadata table exists.

On first use (before any files exist), the repo map will be empty or show only AGENTS.md. As users create files, they appear in subsequent maps with summaries.

---

## Future Enhancements

The initial implementation shows a flat list of all files with summaries. Future enhancements SHOULD improve information density and relevance.

### Intelligent Truncation

As second brains grow beyond 1000 files, showing every file becomes impractical. The system SHOULD implement intelligent truncation showing directory-level summaries for large folders, highlighting recently modified or frequently accessed files, or showing only files relevant to user's current context.

### Hierarchical Summaries

Directory-level summaries could provide overview context: "projects/launch-app/ (23 files) - Mobile app development project targeting Q1 2025 launch with React Native technical stack". This enables understanding project scope without listing all files.

### Temporal Filtering

The map could highlight recent activity: showing files modified in the last 7 days more prominently, fading older files, or providing a "recent changes" section before the full tree. This helps Claude understand what the user has been working on lately.

### Customization

AGENTS.md could allow users to configure map behavior: preferred tree depth, summary length, folder collapse thresholds, or visibility rules (hide archives unless explicitly requested). These customizations would apply during map assembly.

All enhancements are [DEFERRED] pending real-world usage data. The initial implementation establishes the foundation and gathers metrics to inform future improvements.

---

## Cost Analysis

Cloudflare Workers AI pricing for the `@cf/meta/llama-3-8b-instruct` model is approximately $0.01 per million input tokens and $0.10 per million output tokens.

For a typical file summary:
- Input: ~2000 characters (~500 tokens) per file
- Output: ~100 characters (~25 tokens) per summary
- Cost per summary: ~$0.000005 input + $0.0000025 output = ~$0.0000075 per file

For a second brain with 500 files:
- Initial generation: 500 × $0.0000075 = $0.00375 (~$0.004)
- Daily regeneration (assume 5% change rate): 25 × $0.0000075 = $0.0001875 (~$0.0002/day)
- Monthly cost: $0.004 initial + ($0.0002 × 30) = $0.01

This cost is negligible compared to Worker and R2 costs. Summary generation is financially viable even for large knowledge bases.

---

## Related Documentation

- [D1 Database](./d1-database.md) - Metadata storage and caching schema
- [AGENTS.md](./agents-md.md) - User methodology injected before repo map
- [Architecture](./architecture.md) - System prompt composition and MCP initialization
- [Deployment](./deployment.md) - Cron job configuration for daily regeneration
- [Bootstrap](./bootstrap.md) - Initial file creation and migration behavior
